[{"kind":1,"language":"markdown","value":"# Fejlett XML Technológiák Beadandó Projekt\nDate: 2023-10-30     Time: 16:45:06"},{"kind":1,"language":"markdown","value":"# A nem kézi fegyverek nevei betűrendben"},{"kind":2,"language":"xpath","value":"let $weaponsJSON := fn:json-doc(\"./weapons.json\")\nreturn $weaponsJSON?weapons?*[?handHeldWeapon = fn:false()]?name => fn:sort()"},{"kind":1,"language":"markdown","value":"# A leghosszabb nevű projectile (azaz hajító/lövedékes) fegyver(ek)"},{"kind":2,"language":"xpath","value":"let $weaponsJSON := fn:json-doc(\"./weapons.json\"),\n    $maxWeaponLength := $weaponsJSON?weapons?*[?projectileWeapon] ! fn:string-length(?name) => fn:max()\nreturn $weaponsJSON?weapons?*[fn:string-length(?name) eq $maxWeaponLength]?name"},{"kind":1,"language":"markdown","value":"# Egy asszociatív tömb, melyben azon Star Trek epizódok címe, illetve filmbéli ideje szerepel, amelynek a \"kezdési éve\" nem egyezik a \"végződő évvel\""},{"kind":2,"language":"xpath","value":"let $episodesJSON := fn:json-doc(\"./episodes.json\"),\n    $episodesNewYear := $episodesJSON?episodes?*[?yearFrom != ?yearTo]\nreturn map:merge(for $episode in $episodesNewYear return map:entry($episode?title, $episode?yearFrom || \"-\" || $episode?yearTo)) => fn:serialize(map{'method':'json'})"},{"kind":1,"language":"markdown","value":"# Asszociatív tömb, melyben a \"Star Trek: The Original Series\" sorozat azon epizódjai és amerikai sugárzási dátumai találhatóak, melyek 1968.01.01 után voltak sugározva"},{"kind":2,"language":"xpath","value":"let $episodesJSON := fn:json-doc(\"./episodes.json\"),\n    $episodesAfterDate := $episodesJSON?episodes?*[?series?title = \"Star Trek: The Original Series\"][?usAirDate gt \"1968-01-01\"]\nreturn map:merge(for $episode in $episodesAfterDate\n                 return map:entry($episode?title, $episode?usAirDate)) => fn:serialize(map{'method':'json'})"},{"kind":1,"language":"markdown","value":"# A különböző Star Trek sorozatok epizódjainak száma"},{"kind":2,"language":"xpath","value":"let $episodesJSON := fn:json-doc(\"./episodes.json\"),\n$series := $episodesJSON?episodes?*?series?title => fn:distinct-values()\nreturn map:merge(for $s in $series return map:entry($s, fn:count($episodesJSON?episodes?*[?series?title = $s])))"},{"kind":1,"language":"markdown","value":"# A kaliforniai születésű nő színészek neve és születési dátuma a \"EPMA0000001499\" ID-val ellátott epizódban"},{"kind":2,"language":"xpath","value":"let $episodeJSON := fn:json-doc(\"./episode_EPMA0000001499.json\"),\n $femalePerformersCalifornia := $episodeJSON?episode?performers?*[?gender eq \"F\"][fn:contains(?placeOfBirth, \"California\")]\nreturn map:merge(for $performer in $femalePerformersCalifornia return map:entry($performer?name, $performer?dateOfBirth))"},{"kind":1,"language":"markdown","value":"# Azon szereplők lényeges adatai, akiknek a születési éve és halálozási éve is ismert a sorozatban, és legalább 30 évet éltek."},{"kind":2,"language":"xpath","value":"let $episodeJSON := fn:json-doc(\"./episode_EPMA0000001499.json\"),\n$charactersWithLifeLength := $episodeJSON?episode?characters?*[fn:empty(?yearOfBirth) eq false() and fn:empty(?yearOfDeath) eq false()],\n$charactersLivedMoreThanThirty :=$charactersWithLifeLength[?yearOfDeath - ?yearOfBirth gt 30],\n$transformedArray := for $character in $charactersLivedMoreThanThirty\n    return map{\n        \"characterID\": $character?uid,\n        \"name\": $character?name,\n        \"gender\": if ($character?gender = \"M\") then \"Male\" else \"Female\",\n        \"yearOfBirth\": $character?yearOfBirth,\n        \"yearOfDeath\": $character?yearOfDeath,\n        \"lifeInYears\": $character?yearOfDeath - $character?yearOfBirth\n    }\nreturn $transformedArray"},{"kind":1,"language":"markdown","value":"# A színészek (performerek) nevei a színészi pozíciójaikkal párosítva"},{"kind":2,"language":"xpath","value":"let $episodeJSON := fn:json-doc(\"./episode_EPMA0000001499.json\"),\n$performers := $episodeJSON?episode?performers?*,\n$performerCategories := for $performer in $performers return\nmap:entry($performer?name, map:for-each($performer, function($key, $value) {\n    if (contains($key, \"Performer\") and $value = true())\n    then $key\n    else ()\n  }))\n\n\nreturn $performerCategories"},{"kind":2,"language":"xpath","value":"let $episodeJSON := fn:json-doc(\"./episode_EPMA0000001499.json\"),\n$performers := $episodeJSON?episode?performers?*,\n$performerCategories := for $performer in $performers return\nmap{\"name\": $performer?name() , \"categories\": map:for-each($performer, function($key, $value) {\n    if (contains($key, \"Performer\") and $value = true())\n    then $key\n    else ()\n  })},\n$standInPerformers := $performerCategories\n\n\nreturn $standInPerformers"}]